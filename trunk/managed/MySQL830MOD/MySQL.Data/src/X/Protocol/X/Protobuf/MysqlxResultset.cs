// Copyright (c) 2022, 2023, Oracle and/or its affiliates.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License, version 2.0, as
// published by the Free Software Foundation.
//
// This program is also distributed with certain software (including
// but not limited to OpenSSL) that is licensed under separate terms,
// as designated in a particular file or component or in included license
// documentation. The authors of MySQL hereby grant you an
// additional permission to link the program and your derivative works
// with the separately licensed software that they have included with
// MySQL.
//
// Without limiting anything contained in the foregoing, this file,
// which is part of MySQL Connector/NET, is also subject to the
// Universal FOSS Exception, version 1.0, a copy of which can be found at
// http://oss.oracle.com/licenses/universal-foss-exception.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License, version 2.0, for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA

// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: mysqlx_resultset.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Mysqlx.Resultset
{

  /// <summary>Holder for reflection information generated from mysqlx_resultset.proto</summary>
  public static partial class MysqlxResultsetReflection
  {

    #region Descriptor
    /// <summary>File descriptor for mysqlx_resultset.proto</summary>
    public static pbr::FileDescriptor Descriptor
    {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static MysqlxResultsetReflection()
    {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChZteXNxbHhfcmVzdWx0c2V0LnByb3RvEhBNeXNxbHguUmVzdWx0c2V0Ggxt",
            "eXNxbHgucHJvdG8iHgoWRmV0Y2hEb25lTW9yZU91dFBhcmFtczoEkOowEiIf",
            "ChdGZXRjaERvbmVNb3JlUmVzdWx0c2V0czoEkOowECIRCglGZXRjaERvbmU6",
            "BJDqMA4iFgoORmV0Y2hTdXNwZW5kZWQ6BJDqMA8ipQMKDkNvbHVtbk1ldGFE",
            "YXRhEjgKBHR5cGUYASACKA4yKi5NeXNxbHguUmVzdWx0c2V0LkNvbHVtbk1l",
            "dGFEYXRhLkZpZWxkVHlwZRIMCgRuYW1lGAIgASgMEhUKDW9yaWdpbmFsX25h",
            "bWUYAyABKAwSDQoFdGFibGUYBCABKAwSFgoOb3JpZ2luYWxfdGFibGUYBSAB",
            "KAwSDgoGc2NoZW1hGAYgASgMEg8KB2NhdGFsb2cYByABKAwSEQoJY29sbGF0",
            "aW9uGAggASgEEhkKEWZyYWN0aW9uYWxfZGlnaXRzGAkgASgNEg4KBmxlbmd0",
            "aBgKIAEoDRINCgVmbGFncxgLIAEoDRIUCgxjb250ZW50X3R5cGUYDCABKA0i",
            "ggEKCUZpZWxkVHlwZRIICgRTSU5UEAESCAoEVUlOVBACEgoKBkRPVUJMRRAF",
            "EgkKBUZMT0FUEAYSCQoFQllURVMQBxIICgRUSU1FEAoSDAoIREFURVRJTUUQ",
            "DBIHCgNTRVQQDxIICgRFTlVNEBASBwoDQklUEBESCwoHREVDSU1BTBASOgSQ",
            "6jAMIhoKA1JvdxINCgVmaWVsZBgBIAMoDDoEkOowDSo0ChFDb250ZW50VHlw",
            "ZV9CWVRFUxIMCghHRU9NRVRSWRABEggKBEpTT04QAhIHCgNYTUwQAyouChRD",
            "b250ZW50VHlwZV9EQVRFVElNRRIICgREQVRFEAESDAoIREFURVRJTUUQAkIZ",
            "Chdjb20ubXlzcWwuY2oueC5wcm90b2J1Zg=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Mysqlx.MysqlxReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] { typeof(global::Mysqlx.Resultset.ContentType_BYTES), typeof(global::Mysqlx.Resultset.ContentType_DATETIME), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.FetchDoneMoreOutParams), global::Mysqlx.Resultset.FetchDoneMoreOutParams.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.FetchDoneMoreResultsets), global::Mysqlx.Resultset.FetchDoneMoreResultsets.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.FetchDone), global::Mysqlx.Resultset.FetchDone.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.FetchSuspended), global::Mysqlx.Resultset.FetchSuspended.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.ColumnMetaData), global::Mysqlx.Resultset.ColumnMetaData.Parser, new[]{ "Type", "Name", "OriginalName", "Table", "OriginalTable", "Schema", "Catalog", "Collation", "FractionalDigits", "Length", "Flags", "ContentType" }, null, new[]{ typeof(global::Mysqlx.Resultset.ColumnMetaData.Types.FieldType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Mysqlx.Resultset.Row), global::Mysqlx.Resultset.Row.Parser, new[]{ "Field" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  ///*
  ///A hint about the higher-level encoding of a BYTES field
  ///
  ///|type  | value  | description             |
  ///|------| -------|-------------------------|
  ///|BYTES | 0x0001 | GEOMETRY (WKB encoding) |
  ///|BYTES | 0x0002 | JSON (text encoding)    |
  ///|BYTES | 0x0003 | XML (text encoding)     |
  ///
  ///@note
  ///this list isn't comprehensive. As a guideline: the field's value is expected
  ///to pass a validator check on client and server if this field is set.
  ///If the server adds more internal datatypes that rely on BLOB storage
  ///like image manipulation, seeking into complex types in BLOBs, ... more
  ///types will be added.
  /// </summary>
  public enum ContentType_BYTES
  {
    [pbr::OriginalName("GEOMETRY")] Geometry = 1,
    [pbr::OriginalName("JSON")] Json = 2,
    [pbr::OriginalName("XML")] Xml = 3,
  }

  /// <summary>
  ///*
  ///A hint about the higher-level encoding of a DATETIME field
  ///
  ///|type     |value  |description                                |
  ///|---------|-------|-------------------------------------------|
  ///|DATE     |0x0001 |DATETIME contains only date part           |
  ///|DATETIME |0x0002 |DATETIME contains both date and time parts |
  /// </summary>
  public enum ContentType_DATETIME
  {
    [pbr::OriginalName("DATE")] Date = 1,
    [pbr::OriginalName("DATETIME")] Datetime = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  ///*
  ///Resultsets are finished, OUT paramset is next:
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class FetchDoneMoreOutParams : pb::IMessage<FetchDoneMoreOutParams>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
  {
    private static readonly pb::MessageParser<FetchDoneMoreOutParams> _parser = new pb::MessageParser<FetchDoneMoreOutParams>(() => new FetchDoneMoreOutParams());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FetchDoneMoreOutParams> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor
    {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor
    {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FetchDoneMoreOutParams()
    {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FetchDoneMoreOutParams(FetchDoneMoreOutParams other) : this()
    {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FetchDoneMoreOutParams Clone()
    {
      return new FetchDoneMoreOutParams(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other)
    {
      return Equals(other as FetchDoneMoreOutParams);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FetchDoneMoreOutParams other)
    {
      if (ReferenceEquals(other, null))
      {
        return false;
      }
      if (ReferenceEquals(other, this))
      {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode()
    {
      int hash = 1;
      if (_unknownFields != null)
      {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString()
    {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
#else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
    {
      if (_unknownFields != null)
      {
        _unknownFields.WriteTo(ref output);
      }
    }
#endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize()
    {
      int size = 0;
      if (_unknownFields != null)
      {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FetchDoneMoreOutParams other)
    {
      if (other == null)
      {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
    {
      uint tag;
      while ((tag = input.ReadTag()) != 0)
      {
        switch (tag)
        {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
#endif

  }

  /// <summary>
  ///*
  ///Resultset and out-params are finished, but more resultsets available
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class FetchDoneMoreResultsets : pb::IMessage<FetchDoneMoreResultsets>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
  {
    private static readonly pb::MessageParser<FetchDoneMoreResultsets> _parser = new pb::MessageParser<FetchDoneMoreResultsets>(() => new FetchDoneMoreResultsets());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FetchDoneMoreResultsets> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor
    {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor
    {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FetchDoneMoreResultsets()
    {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FetchDoneMoreResultsets(FetchDoneMoreResultsets other) : this()
    {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FetchDoneMoreResultsets Clone()
    {
      return new FetchDoneMoreResultsets(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other)
    {
      return Equals(other as FetchDoneMoreResultsets);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FetchDoneMoreResultsets other)
    {
      if (ReferenceEquals(other, null))
      {
        return false;
      }
      if (ReferenceEquals(other, this))
      {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode()
    {
      int hash = 1;
      if (_unknownFields != null)
      {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString()
    {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
#else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
    {
      if (_unknownFields != null)
      {
        _unknownFields.WriteTo(ref output);
      }
    }
#endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize()
    {
      int size = 0;
      if (_unknownFields != null)
      {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FetchDoneMoreResultsets other)
    {
      if (other == null)
      {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
    {
      uint tag;
      while ((tag = input.ReadTag()) != 0)
      {
        switch (tag)
        {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
#endif

  }

  /// <summary>
  ///*
  ///All resultsets are finished
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class FetchDone : pb::IMessage<FetchDone>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
  {
    private static readonly pb::MessageParser<FetchDone> _parser = new pb::MessageParser<FetchDone>(() => new FetchDone());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FetchDone> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor
    {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor
    {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FetchDone()
    {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FetchDone(FetchDone other) : this()
    {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FetchDone Clone()
    {
      return new FetchDone(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other)
    {
      return Equals(other as FetchDone);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FetchDone other)
    {
      if (ReferenceEquals(other, null))
      {
        return false;
      }
      if (ReferenceEquals(other, this))
      {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode()
    {
      int hash = 1;
      if (_unknownFields != null)
      {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString()
    {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
#else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
    {
      if (_unknownFields != null)
      {
        _unknownFields.WriteTo(ref output);
      }
    }
#endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize()
    {
      int size = 0;
      if (_unknownFields != null)
      {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FetchDone other)
    {
      if (other == null)
      {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
    {
      uint tag;
      while ((tag = input.ReadTag()) != 0)
      {
        switch (tag)
        {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
#endif

  }

  /// <summary>
  ///*
  ///Cursor is opened; still, the execution of PrepFetch or PrepExecute ended
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class FetchSuspended : pb::IMessage<FetchSuspended>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
  {
    private static readonly pb::MessageParser<FetchSuspended> _parser = new pb::MessageParser<FetchSuspended>(() => new FetchSuspended());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FetchSuspended> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor
    {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor
    {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FetchSuspended()
    {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FetchSuspended(FetchSuspended other) : this()
    {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FetchSuspended Clone()
    {
      return new FetchSuspended(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other)
    {
      return Equals(other as FetchSuspended);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FetchSuspended other)
    {
      if (ReferenceEquals(other, null))
      {
        return false;
      }
      if (ReferenceEquals(other, this))
      {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode()
    {
      int hash = 1;
      if (_unknownFields != null)
      {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString()
    {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
#else
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
    {
      if (_unknownFields != null)
      {
        _unknownFields.WriteTo(ref output);
      }
    }
#endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize()
    {
      int size = 0;
      if (_unknownFields != null)
      {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FetchSuspended other)
    {
      if (other == null)
      {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
    {
      uint tag;
      while ((tag = input.ReadTag()) != 0)
      {
        switch (tag)
        {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
        }
      }
    }
#endif

  }

  /// <summary>
  ///*
  ///Meta data of a column
  ///
  ///@note
  ///The encoding used for the different ``bytes`` fields in the
  ///meta data is externally controlled. See also:
  ///https://dev.mysql.com/doc/refman/5.0/en/charset-connection.html
  ///
  ///@par
  ///@note
  ///The server may not set the ``original_{table|name}`` fields
  ///if they are equal to the plain ``{table|name}`` field.
  ///
  ///@par
  ///@note
  ///A client has to reconstruct it like:
  ///@code{py}
  ///if .original_name is empty and .name is not empty:
  ///.original_name = .name
  ///
  ///if .original_table is empty and .table is not empty:
  ///.original_table = .table
  ///@endcode
  ///
  ///@par
  ///@note
  ///``Compact metadata format`` can be requested by the client.
  ///In that case, only ``.type`` is set and all other fields are  empty.
  ///
  ///Expected data type of Mysqlx.Resultset.Row per SQL Type for
  ///non-NULL values:
  ///
  ///| SQL Type          | .type     | .length | .frac\_dig | .flags | .charset |
  ///|-------------------|-----------|---------|------------|--------|----------|
  ///| TINY              | SINT      | x       |            |        |          |
  ///| TINY UNSIGNED     | UINT      | x       |            | x      |          |
  ///| SHORT             | SINT      | x       |            |        |          |
  ///| SHORT UNSIGNED    | UINT      | x       |            | x      |          |
  ///| INT24             | SINT      | x       |            |        |          |
  ///| INT24 UNSIGNED    | UINT      | x       |            | x      |          |
  ///| INT               | SINT      | x       |            |        |          |
  ///| INT UNSIGNED      | UINT      | x       |            | x      |          |
  ///| LONGLONG          | SINT      | x       |            |        |          |
  ///| LONGLONG UNSIGNED | UINT      | x       |            | x      |          |
  ///| DOUBLE            | DOUBLE    | x       | x          | x      |          |
  ///| FLOAT             | FLOAT     | x       | x          | x      |          |
  ///| DECIMAL           | DECIMAL   | x       | x          | x      |          |
  ///| VARCHAR,CHAR,...  | BYTES     | x       |            | x      | x        |
  ///| GEOMETRY          | BYTES     |         |            |        |          |
  ///| TIME              | TIME      | x       |            |        |          |
  ///| DATE              | DATETIME  | x       |            |        |          |
  ///| DATETIME          | DATETIME  | x       |            |        |          |
  ///| YEAR              | UINT      | x       |            | x      |          |
  ///| TIMESTAMP         | DATETIME  | x       |            |        |          |
  ///| SET               | SET       |         |            |        | x        |
  ///| ENUM              | ENUM      |         |            |        | x        |
  ///| NULL              | BYTES     |         |            |        |          |
  ///| BIT               | BIT       | x       |            |        |          |
  ///
  ///@note
  ///The SQL "NULL" value is sent as an empty field value in
  ///@ref Mysqlx::Resultset::Row.
  ///
  ///@par Tip
  ///The protobuf encoding of primitive data types is described in
  ///https://developers.google.com/protocol-buffers/docs/encoding
  ///
  ///+ SINT
  ///
  ///- ``.length`` @n
  ///Maximum number of displayable decimal digits (including
  ///minus sign) of the type.
  ///@note
  ///The valid range is 0-255, but usually you'll see 1-20.
  ///
  ///| SQL Type         | Maximum Digits per Type |
  ///|------------------|-------------------------|
  ///| TINY SIGNED      | 4                       |
  ///| SHORT SIGNED     | 6                       |
  ///| INT24 SIGNED     | 8                       |
  ///| INT SIGNED       | 11                      |
  ///| LONGLONG SIGNED  | 20                      |
  ///
  ///@par Tip
  ///Definition of ``M`` are in
  ///https://dev.mysql.com/doc/refman/5.5/en/numeric-type-overview.html.
  ///
  ///- ``value``@n
  ///Variable length encoded signed 64 integer.
  ///
  ///+ UINT
  ///
  ///- ``.flags &amp; 1`` (zerofill) @n
  ///The client has to left pad with 0's up to .length.
  ///
  ///- ``.length`` @n
  ///Maximum number of displayable decimal digits of the
  ///type.
  ///@note
  ///The valid range is 0-255, but usually you'll see
  ///1-20.
  ///
  ///| SQL Type             | max digits per type |
  ///|----------------------|---------------------|
  ///| TINY UNSIGNED        | 3                   |
  ///| SHORT UNSIGNED       | 5                   |
  ///| INT24 UNSIGNED       | 8                   |
  ///| INT UNSIGNED         | 10                  |
  ///| LONGLONG UNSIGNED    | 20                  |
  ///
  ///@par Tip
  ///Definition of ``M`` are in
  ///https://dev.mysql.com/doc/refman/5.5/en/numeric-type-overview.html.
  ///
  ///- ``value`` @n
  ///Variable length encoded unsigned 64 integer.
  ///
  ///+ BIT
  ///
  ///- ``.length`` @n
  ///Maximum number of displayable binary digits.
  ///@note
  ///The valid range for M of the ``BIT`` type is 1 - 64.
  ///
  ///@par Tip
  ///https://dev.mysql.com/doc/refman/5.5/en/numeric-type-overview.html
  ///
  ///- ``value`` @n
  ///Variable length encoded unsigned 64 integer.
  ///
  ///+ DOUBLE
  ///
  ///- ``.length`` @n
  ///Maximum number of displayable decimal digits (including
  ///the decimal point and ``.fractional_digits``).
  ///
  ///- ``.fractional_digits`` @n
  ///Maximum number of displayable decimal digits following
  ///the decimal point.
  ///
  ///- ``value``@n
  ///Encoded as protobuf's 'double'.
  ///
  ///+ FLOAT
  ///
  ///- ``.length``@n
  ///Maximum number of displayable decimal digits (including
  ///the decimal point and ``.fractional_digits``).
  ///
  ///- ``.fractional_digits``@n
  ///Maximum number of displayable decimal digits following
  ///the decimal point.
  ///
  ///- ``value``@n
  ///Encoded as protobuf's 'float'.
  ///
  ///+ BYTES, ENUM
  ///@note
  ///BYTES is used for all opaque byte strings that may have a charset:
  ///-  TINYBLOB, BLOB, MEDIUMBLOB, LONGBLOB
  ///-  TINYTEXT, TEXT, MEDIUMTEXT, LONGTEXT
  ///-  VARCHAR, VARBINARY
  ///-  CHAR, BINARY
  ///-  ENUM
  ///
  ///- ``.length``@n
  ///Maximum length of characters of the underlying type.
  ///
  ///- ``.flags &amp; 1`` (rightpad) @n
  ///If the length of the field is less than ``.length``, the
  ///receiver is supposed to add padding characters to the
  ///right end of the string. If the ``.charset`` is
  ///"binary", the padding character is ``0x00``, otherwise
  ///it is a space character as defined by that character
  ///set.
  ///| SQL Type      | .length  | .charset  | .flags   |
  ///|---------------|----------|-----------|----------|
  ///| TINYBLOB      | 256      | binary    |          |
  ///| BLOB          | 65535    | binary    |          |
  ///| VARCHAR(32)   | 32       | utf8      |          |
  ///| VARBINARY(32) | 32       | utf8\_bin |          |
  ///| BINARY(32)    | 32       | binary    | rightpad |
  ///| CHAR(32)      | 32       | utf8      | rightpad |
  ///
  ///- ``value``
  ///Sequence of bytes with added one extra ``0x00`` byte at
  ///the end. To obtain the original string, the extra
  ///``0x00`` should be removed. The length of the string can
  ///be acquired with protobuf's field ``length()`` method:
  ///
  ///``length of sequence-of-bytes = length-of-field - 1``
  ///@note
  ///The extra byte allows to distinguish between a NULL
  ///and empty byte sequence.
  ///
  ///+ TIME
  ///
  ///A time value.
  ///
  ///- ``value``@n
  ///The following bytes sequence:
  ///
  ///``negate [ hour [ minutes [ seconds [ useconds ]]]]``
  ///
  ///-  negate - one byte, should be one of: 0x00 for "+",
  ///0x01 for "-"
  ///
  ///-  hour - optional variable length encoded unsigned64
  ///value for the hour
  ///
  ///-  minutes - optional variable length encoded unsigned64
  ///value for the minutes
  ///
  ///-  seconds - optional variable length encoded unsigned64
  ///value for the seconds
  ///
  ///-  useconds - optional variable length encoded
  ///unsigned64 value for the microseconds
  ///
  ///@par Tip
  ///The protobuf encoding in
  ///https://developers.google.com/protocol-buffers/docs/encoding.
  ///
  ///@note
  ///Hour, minutes, seconds, and useconds are optional if
  ///all the values to the right are 0.
  ///
  ///Example: ``0x00 -> +00:00:00.000000``
  ///
  ///+ DATETIME
  ///
  ///A date or date and time value.
  ///
  ///- ``value`` @n
  ///A sequence of variants, arranged as follows:
  ///
  ///``| year | month | day | [ | hour | [ | minutes | [ | seconds | [ | useconds | ]]]]``
  ///
  ///-  year - variable length encoded unsigned64 value for
  ///the year
  ///
  ///-  month - variable length encoded unsigned64 value for
  ///the month
  ///
  ///-  day - variable length encoded unsigned64 value for
  ///the day
  ///
  ///-  hour - optional variable length encoded unsigned64
  ///value for the hour
  ///
  ///-  minutes - optional variable length encoded unsigned64
  ///value for the minutes
  ///
  ///-  seconds - optional variable length encoded unsigned64
  ///value for the seconds
  ///
  ///-  useconds - optional variable length encoded
  ///unsigned64 value for the microseconds
  ///@note
  ///Hour, minutes, seconds, useconds are optional if all
  ///the values to the right are 0.
  ///
  ///- ``.flags``@n
  ///| Name          | Position |
  ///|---------------|----------|
  ///| is\_timestamp | 1        |
  ///
  ///+ DECIMAL
  ///
  ///An arbitrary length number. The number is encoded as a
  ///single byte indicating the position of the decimal point
  ///followed by the Packed BCD encoded number. Packed BCD is
  ///used to simplify conversion to and from strings and other
  ///native arbitrary precision math data types. See also: packed
  ///BCD in https://en.wikipedia.org/wiki/Binary-coded_decimal
  ///
  ///- ``.length``
  ///Maximum number of displayable decimal digits
  ///(*excluding* the decimal point and sign, but including
  ///``.fractional_digits``).
  ///@note
  ///Should be in the range of 1 - 65.
  ///
  ///- ``.fractional_digits``
  ///The decimal digits to display out of length.
  ///@note
  ///Should be in the range of 0 - 30.
  ///
  ///``value``
  ///The following bytes sequence:
  ///
  ///``scale | BCD+ sign [0x00]?``
  ///
  ///-  scale - 8bit scale value (number of decimal digit after the '.')
  ///
  ///-  BCD - BCD encoded digits (4 bits for each digit)
  ///
  ///-  sign - sign encoded on 4 bits (0xc = "+", 0xd = "-")
  ///
  ///-  0x0 - last 4bits if length(digits) % 2 == 0
  ///
  ///Example: ``x04 0x12 0x34 0x01
  ///0xd0 -> -12.3401``
  ///
  ///+ SET
  ///
  ///A list of strings representing a SET of values.
  ///
  ///- ``value``@n
  ///A sequence of 0 or more of protobuf's bytes (length
  ///prepended octets) or one of the special sequences with a
  ///predefined meaning listed below.
  ///
  ///Example (length of the bytes array shown in brackets):
  ///-  ``[0]`` - the NULL value
  ///
  ///-  ``[1] 0x00`` - a set containing a blank string ''
  ///
  ///-  ``[1] 0x01`` - this would be an invalid value,
  ///but is to be treated as the empty set
  ///
  ///-  ``[2] 0x01 0x00`` - a set with a single item, which is the '0'
  ///character
  ///
  ///-  ``[8] 0x03 F O O 0x03 B A R`` - a set with 2 items: FOO,BAR
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ColumnMetaData : pb::IMessage<ColumnMetaData>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
  {
    private static readonly pb::MessageParser<ColumnMetaData> _parser = new pb::MessageParser<ColumnMetaData>(() => new ColumnMetaData());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ColumnMetaData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor
    {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor
    {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ColumnMetaData()
    {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ColumnMetaData(ColumnMetaData other) : this()
    {
      _hasBits0 = other._hasBits0;
      type_ = other.type_;
      name_ = other.name_;
      originalName_ = other.originalName_;
      table_ = other.table_;
      originalTable_ = other.originalTable_;
      schema_ = other.schema_;
      catalog_ = other.catalog_;
      collation_ = other.collation_;
      fractionalDigits_ = other.fractionalDigits_;
      length_ = other.length_;
      flags_ = other.flags_;
      contentType_ = other.contentType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ColumnMetaData Clone()
    {
      return new ColumnMetaData(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static global::Mysqlx.Resultset.ColumnMetaData.Types.FieldType TypeDefaultValue = global::Mysqlx.Resultset.ColumnMetaData.Types.FieldType.Sint;

    private global::Mysqlx.Resultset.ColumnMetaData.Types.FieldType type_;
    /// <summary>
    ///* datatype of the field in a row 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Mysqlx.Resultset.ColumnMetaData.Types.FieldType Type
    {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set
      {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType
    {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType()
    {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private readonly static pb::ByteString NameDefaultValue = pb::ByteString.Empty;

    private pb::ByteString name_;
    /// <summary>
    ///* name of the column 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Name
    {
      get { return name_ ?? NameDefaultValue; }
      set
      {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName
    {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName()
    {
      name_ = null;
    }

    /// <summary>Field number for the "original_name" field.</summary>
    public const int OriginalNameFieldNumber = 3;
    private readonly static pb::ByteString OriginalNameDefaultValue = pb::ByteString.Empty;

    private pb::ByteString originalName_;
    /// <summary>
    ///* name of the column before an alias was applied 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString OriginalName
    {
      get { return originalName_ ?? OriginalNameDefaultValue; }
      set
      {
        originalName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "original_name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOriginalName
    {
      get { return originalName_ != null; }
    }
    /// <summary>Clears the value of the "original_name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOriginalName()
    {
      originalName_ = null;
    }

    /// <summary>Field number for the "table" field.</summary>
    public const int TableFieldNumber = 4;
    private readonly static pb::ByteString TableDefaultValue = pb::ByteString.Empty;

    private pb::ByteString table_;
    /// <summary>
    ///* name of the table the column originates from 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Table
    {
      get { return table_ ?? TableDefaultValue; }
      set
      {
        table_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "table" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTable
    {
      get { return table_ != null; }
    }
    /// <summary>Clears the value of the "table" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTable()
    {
      table_ = null;
    }

    /// <summary>Field number for the "original_table" field.</summary>
    public const int OriginalTableFieldNumber = 5;
    private readonly static pb::ByteString OriginalTableDefaultValue = pb::ByteString.Empty;

    private pb::ByteString originalTable_;
    /// <summary>
    ///* name of the table the column originates from before an alias was applied 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString OriginalTable
    {
      get { return originalTable_ ?? OriginalTableDefaultValue; }
      set
      {
        originalTable_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "original_table" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOriginalTable
    {
      get { return originalTable_ != null; }
    }
    /// <summary>Clears the value of the "original_table" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOriginalTable()
    {
      originalTable_ = null;
    }

    /// <summary>Field number for the "schema" field.</summary>
    public const int SchemaFieldNumber = 6;
    private readonly static pb::ByteString SchemaDefaultValue = pb::ByteString.Empty;

    private pb::ByteString schema_;
    /// <summary>
    ///* schema the column originates from 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Schema
    {
      get { return schema_ ?? SchemaDefaultValue; }
      set
      {
        schema_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "schema" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSchema
    {
      get { return schema_ != null; }
    }
    /// <summary>Clears the value of the "schema" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSchema()
    {
      schema_ = null;
    }

    /// <summary>Field number for the "catalog" field.</summary>
    public const int CatalogFieldNumber = 7;
    private readonly static pb::ByteString CatalogDefaultValue = pb::ByteString.Empty;

    private pb::ByteString catalog_;
    /// <summary>
    ///* catalog the schema originates from
    ///@note
    ///As there is currently no support for catalogs in MySQL,
    ///don't expect this field to be set. In the MySQL C/S
    ///protocol the field had the value ``def`` all the time 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Catalog
    {
      get { return catalog_ ?? CatalogDefaultValue; }
      set
      {
        catalog_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "catalog" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCatalog
    {
      get { return catalog_ != null; }
    }
    /// <summary>Clears the value of the "catalog" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCatalog()
    {
      catalog_ = null;
    }

    /// <summary>Field number for the "collation" field.</summary>
    public const int CollationFieldNumber = 8;
    private readonly static ulong CollationDefaultValue = 0UL;

    private ulong collation_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Collation
    {
      get { if ((_hasBits0 & 2) != 0) { return collation_; } else { return CollationDefaultValue; } }
      set
      {
        _hasBits0 |= 2;
        collation_ = value;
      }
    }
    /// <summary>Gets whether the "collation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCollation
    {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "collation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCollation()
    {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "fractional_digits" field.</summary>
    public const int FractionalDigitsFieldNumber = 9;
    private readonly static uint FractionalDigitsDefaultValue = 0;

    private uint fractionalDigits_;
    /// <summary>
    ///* displayed factional decimal digits for floating point and
    ///fixed point numbers 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint FractionalDigits
    {
      get { if ((_hasBits0 & 4) != 0) { return fractionalDigits_; } else { return FractionalDigitsDefaultValue; } }
      set
      {
        _hasBits0 |= 4;
        fractionalDigits_ = value;
      }
    }
    /// <summary>Gets whether the "fractional_digits" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFractionalDigits
    {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "fractional_digits" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFractionalDigits()
    {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "length" field.</summary>
    public const int LengthFieldNumber = 10;
    private readonly static uint LengthDefaultValue = 0;

    private uint length_;
    /// <summary>
    ///* maximum count of displayable characters of .type 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Length
    {
      get { if ((_hasBits0 & 8) != 0) { return length_; } else { return LengthDefaultValue; } }
      set
      {
        _hasBits0 |= 8;
        length_ = value;
      }
    }
    /// <summary>Gets whether the "length" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLength
    {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "length" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLength()
    {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "flags" field.</summary>
    public const int FlagsFieldNumber = 11;
    private readonly static uint FlagsDefaultValue = 0;

    private uint flags_;
    /// <summary>
    ///* ``.type`` specific flags
    ///| Type    | Value  | Description  |
    ///|---------|--------|--------------|
    ///| UINT    | 0x0001 | zerofill     |
    ///| DOUBLE  | 0x0001 | unsigned     |
    ///| FLOAT   | 0x0001 | unsigned     |
    ///| DECIMAL | 0x0001 | unsigned     |
    ///| BYTES   | 0x0001 | rightpad     |
    ///
    ///| Value  | Description     |
    ///|--------|-----------------|
    ///| 0x0010 | NOT\_NULL       |
    ///| 0x0020 | PRIMARY\_KEY    |
    ///| 0x0040 | UNIQUE\_KEY     |
    ///| 0x0080 | MULTIPLE\_KEY   |
    ///| 0x0100 | AUTO\_INCREMENT |
    ///
    ///default: 0 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Flags
    {
      get { if ((_hasBits0 & 16) != 0) { return flags_; } else { return FlagsDefaultValue; } }
      set
      {
        _hasBits0 |= 16;
        flags_ = value;
      }
    }
    /// <summary>Gets whether the "flags" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFlags
    {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "flags" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFlags()
    {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "content_type" field.</summary>
    public const int ContentTypeFieldNumber = 12;
    private readonly static uint ContentTypeDefaultValue = 0;

    private uint contentType_;
    /// <summary>
    ///* a hint about the higher-level encoding of a BYTES field
    ///| Type   | Value  | Description             |
    ///|--------|--------|-------------------------|
    ///| BYTES  | 0x0001 | GEOMETRY (WKB encoding) |
    ///| BYTES  | 0x0002 | JSON (text encoding)    |
    ///| BYTES  | 0x0003 | XML (text encoding)     |
    ///@note
    ///This list isn't comprehensive. As a guideline: the field's
    ///value is expected to pass a validator check on client
    ///and server if this field is set. If the server adds more
    ///internal data types that rely on BLOB storage like image
    ///manipulation, seeking into complex types in BLOBs, and
    ///more types will be added 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint ContentType
    {
      get { if ((_hasBits0 & 32) != 0) { return contentType_; } else { return ContentTypeDefaultValue; } }
      set
      {
        _hasBits0 |= 32;
        contentType_ = value;
      }
    }
    /// <summary>Gets whether the "content_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContentType
    {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "content_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContentType()
    {
      _hasBits0 &= ~32;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other)
    {
      return Equals(other as ColumnMetaData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ColumnMetaData other)
    {
      if (ReferenceEquals(other, null))
      {
        return false;
      }
      if (ReferenceEquals(other, this))
      {
        return true;
      }
      if (Type != other.Type) return false;
      if (Name != other.Name) return false;
      if (OriginalName != other.OriginalName) return false;
      if (Table != other.Table) return false;
      if (OriginalTable != other.OriginalTable) return false;
      if (Schema != other.Schema) return false;
      if (Catalog != other.Catalog) return false;
      if (Collation != other.Collation) return false;
      if (FractionalDigits != other.FractionalDigits) return false;
      if (Length != other.Length) return false;
      if (Flags != other.Flags) return false;
      if (ContentType != other.ContentType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode()
    {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasName) hash ^= Name.GetHashCode();
      if (HasOriginalName) hash ^= OriginalName.GetHashCode();
      if (HasTable) hash ^= Table.GetHashCode();
      if (HasOriginalTable) hash ^= OriginalTable.GetHashCode();
      if (HasSchema) hash ^= Schema.GetHashCode();
      if (HasCatalog) hash ^= Catalog.GetHashCode();
      if (HasCollation) hash ^= Collation.GetHashCode();
      if (HasFractionalDigits) hash ^= FractionalDigits.GetHashCode();
      if (HasLength) hash ^= Length.GetHashCode();
      if (HasFlags) hash ^= Flags.GetHashCode();
      if (HasContentType) hash ^= ContentType.GetHashCode();
      if (_unknownFields != null)
      {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString()
    {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
#else
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (HasName) {
        output.WriteRawTag(18);
        output.WriteBytes(Name);
      }
      if (HasOriginalName) {
        output.WriteRawTag(26);
        output.WriteBytes(OriginalName);
      }
      if (HasTable) {
        output.WriteRawTag(34);
        output.WriteBytes(Table);
      }
      if (HasOriginalTable) {
        output.WriteRawTag(42);
        output.WriteBytes(OriginalTable);
      }
      if (HasSchema) {
        output.WriteRawTag(50);
        output.WriteBytes(Schema);
      }
      if (HasCatalog) {
        output.WriteRawTag(58);
        output.WriteBytes(Catalog);
      }
      if (HasCollation) {
        output.WriteRawTag(64);
        output.WriteUInt64(Collation);
      }
      if (HasFractionalDigits) {
        output.WriteRawTag(72);
        output.WriteUInt32(FractionalDigits);
      }
      if (HasLength) {
        output.WriteRawTag(80);
        output.WriteUInt32(Length);
      }
      if (HasFlags) {
        output.WriteRawTag(88);
        output.WriteUInt32(Flags);
      }
      if (HasContentType) {
        output.WriteRawTag(96);
        output.WriteUInt32(ContentType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
    {
      if (HasType)
      {
        output.WriteRawTag(8);
        output.WriteEnum((int)Type);
      }
      if (HasName)
      {
        output.WriteRawTag(18);
        output.WriteBytes(Name);
      }
      if (HasOriginalName)
      {
        output.WriteRawTag(26);
        output.WriteBytes(OriginalName);
      }
      if (HasTable)
      {
        output.WriteRawTag(34);
        output.WriteBytes(Table);
      }
      if (HasOriginalTable)
      {
        output.WriteRawTag(42);
        output.WriteBytes(OriginalTable);
      }
      if (HasSchema)
      {
        output.WriteRawTag(50);
        output.WriteBytes(Schema);
      }
      if (HasCatalog)
      {
        output.WriteRawTag(58);
        output.WriteBytes(Catalog);
      }
      if (HasCollation)
      {
        output.WriteRawTag(64);
        output.WriteUInt64(Collation);
      }
      if (HasFractionalDigits)
      {
        output.WriteRawTag(72);
        output.WriteUInt32(FractionalDigits);
      }
      if (HasLength)
      {
        output.WriteRawTag(80);
        output.WriteUInt32(Length);
      }
      if (HasFlags)
      {
        output.WriteRawTag(88);
        output.WriteUInt32(Flags);
      }
      if (HasContentType)
      {
        output.WriteRawTag(96);
        output.WriteUInt32(ContentType);
      }
      if (_unknownFields != null)
      {
        _unknownFields.WriteTo(ref output);
      }
    }
#endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize()
    {
      int size = 0;
      if (HasType)
      {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Type);
      }
      if (HasName)
      {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Name);
      }
      if (HasOriginalName)
      {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(OriginalName);
      }
      if (HasTable)
      {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Table);
      }
      if (HasOriginalTable)
      {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(OriginalTable);
      }
      if (HasSchema)
      {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Schema);
      }
      if (HasCatalog)
      {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Catalog);
      }
      if (HasCollation)
      {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Collation);
      }
      if (HasFractionalDigits)
      {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FractionalDigits);
      }
      if (HasLength)
      {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Length);
      }
      if (HasFlags)
      {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Flags);
      }
      if (HasContentType)
      {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ContentType);
      }
      if (_unknownFields != null)
      {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ColumnMetaData other)
    {
      if (other == null)
      {
        return;
      }
      if (other.HasType)
      {
        Type = other.Type;
      }
      if (other.HasName)
      {
        Name = other.Name;
      }
      if (other.HasOriginalName)
      {
        OriginalName = other.OriginalName;
      }
      if (other.HasTable)
      {
        Table = other.Table;
      }
      if (other.HasOriginalTable)
      {
        OriginalTable = other.OriginalTable;
      }
      if (other.HasSchema)
      {
        Schema = other.Schema;
      }
      if (other.HasCatalog)
      {
        Catalog = other.Catalog;
      }
      if (other.HasCollation)
      {
        Collation = other.Collation;
      }
      if (other.HasFractionalDigits)
      {
        FractionalDigits = other.FractionalDigits;
      }
      if (other.HasLength)
      {
        Length = other.Length;
      }
      if (other.HasFlags)
      {
        Flags = other.Flags;
      }
      if (other.HasContentType)
      {
        ContentType = other.ContentType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = (global::Mysqlx.Resultset.ColumnMetaData.Types.FieldType) input.ReadEnum();
            break;
          }
          case 18: {
            Name = input.ReadBytes();
            break;
          }
          case 26: {
            OriginalName = input.ReadBytes();
            break;
          }
          case 34: {
            Table = input.ReadBytes();
            break;
          }
          case 42: {
            OriginalTable = input.ReadBytes();
            break;
          }
          case 50: {
            Schema = input.ReadBytes();
            break;
          }
          case 58: {
            Catalog = input.ReadBytes();
            break;
          }
          case 64: {
            Collation = input.ReadUInt64();
            break;
          }
          case 72: {
            FractionalDigits = input.ReadUInt32();
            break;
          }
          case 80: {
            Length = input.ReadUInt32();
            break;
          }
          case 88: {
            Flags = input.ReadUInt32();
            break;
          }
          case 96: {
            ContentType = input.ReadUInt32();
            break;
          }
        }
      }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
    {
      uint tag;
      while ((tag = input.ReadTag()) != 0)
      {
        switch (tag)
        {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8:
            {
              Type = (global::Mysqlx.Resultset.ColumnMetaData.Types.FieldType)input.ReadEnum();
              break;
            }
          case 18:
            {
              Name = input.ReadBytes();
              break;
            }
          case 26:
            {
              OriginalName = input.ReadBytes();
              break;
            }
          case 34:
            {
              Table = input.ReadBytes();
              break;
            }
          case 42:
            {
              OriginalTable = input.ReadBytes();
              break;
            }
          case 50:
            {
              Schema = input.ReadBytes();
              break;
            }
          case 58:
            {
              Catalog = input.ReadBytes();
              break;
            }
          case 64:
            {
              Collation = input.ReadUInt64();
              break;
            }
          case 72:
            {
              FractionalDigits = input.ReadUInt32();
              break;
            }
          case 80:
            {
              Length = input.ReadUInt32();
              break;
            }
          case 88:
            {
              Flags = input.ReadUInt32();
              break;
            }
          case 96:
            {
              ContentType = input.ReadUInt32();
              break;
            }
        }
      }
    }
#endif

    #region Nested types
    /// <summary>Container for nested types declared in the ColumnMetaData message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types
    {
      public enum FieldType
      {
        [pbr::OriginalName("SINT")] Sint = 1,
        [pbr::OriginalName("UINT")] Uint = 2,
        [pbr::OriginalName("DOUBLE")] Double = 5,
        [pbr::OriginalName("FLOAT")] Float = 6,
        [pbr::OriginalName("BYTES")] Bytes = 7,
        [pbr::OriginalName("TIME")] Time = 10,
        [pbr::OriginalName("DATETIME")] Datetime = 12,
        [pbr::OriginalName("SET")] Set = 15,
        [pbr::OriginalName("ENUM")] Enum = 16,
        [pbr::OriginalName("BIT")] Bit = 17,
        [pbr::OriginalName("DECIMAL")] Decimal = 18,
      }

    }
    #endregion

  }

  /// <summary>
  ///*
  ///Row in a Resultset.
  ///
  ///A row is represented as a list of fields encoded as byte blobs.
  ///Value of each field is encoded as sequence of bytes using
  ///encoding appropriate for the type of the value given by
  ///``ColumnMetadata``, as specified in the @ref Mysqlx::Resultset::ColumnMetaData
  ///description.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Row : pb::IMessage<Row>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
#endif
  {
    private static readonly pb::MessageParser<Row> _parser = new pb::MessageParser<Row>(() => new Row());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Row> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor
    {
      get { return global::Mysqlx.Resultset.MysqlxResultsetReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor
    {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Row()
    {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Row(Row other) : this()
    {
      field_ = other.field_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Row Clone()
    {
      return new Row(this);
    }

    /// <summary>Field number for the "field" field.</summary>
    public const int FieldFieldNumber = 1;
    private static readonly pb::FieldCodec<pb::ByteString> _repeated_field_codec
        = pb::FieldCodec.ForBytes(10);
    private readonly pbc::RepeatedField<pb::ByteString> field_ = new pbc::RepeatedField<pb::ByteString>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<pb::ByteString> Field
    {
      get { return field_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other)
    {
      return Equals(other as Row);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Row other)
    {
      if (ReferenceEquals(other, null))
      {
        return false;
      }
      if (ReferenceEquals(other, this))
      {
        return true;
      }
      if (!field_.Equals(other.field_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode()
    {
      int hash = 1;
      hash ^= field_.GetHashCode();
      if (_unknownFields != null)
      {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString()
    {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
#else
      field_.WriteTo(output, _repeated_field_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output)
    {
      field_.WriteTo(ref output, _repeated_field_codec);
      if (_unknownFields != null)
      {
        _unknownFields.WriteTo(ref output);
      }
    }
#endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize()
    {
      int size = 0;
      size += field_.CalculateSize(_repeated_field_codec);
      if (_unknownFields != null)
      {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Row other)
    {
      if (other == null)
      {
        return;
      }
      field_.Add(other.field_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input)
    {
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
#else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            field_.AddEntriesFrom(input, _repeated_field_codec);
            break;
          }
        }
      }
#endif
    }

#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input)
    {
      uint tag;
      while ((tag = input.ReadTag()) != 0)
      {
        switch (tag)
        {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
            {
              field_.AddEntriesFrom(ref input, _repeated_field_codec);
              break;
            }
        }
      }
    }
#endif

  }

  #endregion

}

#endregion Designer generated code
